
AVRA   Ver. 1.3.0 timer.asm Thu Dec 07 20:53:55 2017


         ;;; Includes
          	.list
            .include "roanlib.asm"        ; Handy Fxns
         ;;; roanlib.asm ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         ;
         ;  A Gathering of handy macros, not necessarily authored by me.
         ;
         ;;;~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
         
           ;; Standard Stack Pointer Initialization
            .macro init_sp
          	  ldi r16,low(RAMEND)
          	  out SPL,r16
          	  ldi r16,high(RAMEND)
          	  out SPH,r16
          	.endmacro
         
           ;; Converts number in register to a hex digit 0-F or '#' if out of range
           ;; Params:  @0 register to convert. 16 <= r <= 31
           ;; Result:  Converted number -> @0
          .macro hex_to_letter
            cpi @0, $0A
            brge hex_to_letter_geA
            subi @0, -0x30
            jmp hex_to_letter_done
          hex_to_letter_geA:
            cpi @0, $10
            brge 	hex_to_letter_out_of_range
            subi @0, -0x37
            jmp hex_to_letter_done
          hex_to_letter_out_of_range:
            ldi @0, '#'
          hex_to_letter_done:
          .endmacro
         
         
         ; ---------------------------------------------------------------------------
         ; Name:     lcd_write_string_4d_mem
         ; Purpose:  display a string of characters on the LCD
         ; Entry:    XH and XL pointing to the start of the string
         ;           (temp_r16) contains the desired DDRAM address at which to start the display
         ; Exit:     no parameters
         ; Notes:    the string must end with a null (0)
         ;           uses time delays instead of checking the busy flag
         
          .macro import_lcd_write_string_4d_mem
          lcd_write_string_4d_mem:
         ; preserve registers
              push    XH                              ; preserve pointer registers
              push    XL
          
         ; STEP NOT NEEDED ~fix up the pointers for use with the 'lpm' instruction~
             ;; lsl     XL                              ; shift the pointer one bit left for the lpm instruction
             ;; rol     XH
          
         ; set up the initial DDRAM address
              ori     temp_r16, lcd_SetCursor     ; convert the plain address to a set cursor instruction
              call   lcd_write_instruction_4d     ; set up the first DDRAM address
              ldi     temp_r16, 80                ; 40 uS delay (min)
              call    delayTx1uS
          
         ; write the string of characters
          lcd_write_string_4d_mem_01:
              ld      temp_r16, X+                        ; get a character
              cpi     temp_r16,  0                        ; check for end of string
              breq    lcd_write_string_4d_mem_02          ; done
          
         ; arrive here if this is a valid character
              call    lcd_write_character_4d          ; display the character
              ldi     temp_r16, 80                        ; 40 uS delay (min)
              call    delayTx1uS
              rjmp    lcd_write_string_4d_mem_01          ; not done, send another character
          
         ; arrive here when all characters in the message have been sent to the LCD module
          lcd_write_string_4d_mem_02:
              pop     XL                              ; restore pointer registers
              pop     XH
              ret
          .endmacro
         
         	;; Display a string from code memory
         	;; Parameters are string_pointer, {lcd_lineone, lcd_linetwo}
         	;; Source: Mick Walters
          	  .macro disp_from_cm
          	    ldi ZH, high(@0) ; Z = Code/Flash memory address of
          	    ldi ZL, low(@0) ; message to be displayed
          	    ldi r16, @1 ; r16 = line 1 LCD address
          	    call lcd_write_string_4d
          	  .endmacro
         
         ;; Display a string from SRAM
         ;; Parameters are string_pointer, {lcd_lineone, lcd_linetwo}
         ;; Source: Mick Walters
             .macro disp_from_sram
               ldi XH, high(@0) ; Z = Code/Flash memory address of
               ldi XL, low(@0) ; message to be displayed
               ldi r16, @1 ; r16 = line 1 LCD address
               call lcd_write_string_4d_mem
             .endmacro
         
           ;; Load an address into letter register without left shift
            .macro load_addr
              ldi @0L, low(@1)
              ldi @0H, high(@1)
            .endmacro
         
         
         ;;; Definitions
            .def temp_r16=r16
            .def interupt_ctr=r17
         
         
         ;;; Macros
           ;; Display the number in a given register on a given line
           ;; .macro display_num
         
         
         ;;; Interupt Vectors
            .org 0x0000
C:000000 940c 00ec                jmp RESET
            .org 0x001A                  ; This is the tiemer interupt vector.
C:00001a 940c 00cb                jmp TIMER1_OVR
         
         
         ;;; Static Variable Planning
            .dseg
D:000100    counter_str:  .byte 2          ; Counter string w/ null space
         
         
         ;;; Beginning code above interupt vectors
            .org INT_VECTORS_SIZE
         
         
         ;;; Functions
            .cseg                         ; TODO: Why does this get rid of branch length errors?
           ;; Display Init
            .list
         
         ;;; Timer ISR
            .cseg
          TIMER1_OVR:
           ;; Note: Not storing Stat Reg because I am lazy and know it does not matter in this case
C:0000cb 301f        cpi interupt_ctr, $0F
C:0000cc f019        breq TIMER1_OVR_CTR_OVR
C:0000cd 9513        inc interupt_ctr
C:0000ce 940c 00d1   jmp	TIMER1_OVR_DISP
          TIMER1_OVR_CTR_OVR:
C:0000d0 2711        clr interupt_ctr
          TIMER1_OVR_DISP:
C:0000d1 e000        ldi temp_r16, $00
C:0000d2 6800        ori temp_r16, lcd_SetCursor     ; convert the plain address to a set cursor instruction
C:0000d3 940e 007c   call lcd_write_instruction_4d
         
C:0000d5 2f01        mov temp_r16, interupt_ctr
C:0000d6   +    hex_to_letter temp_r16
C:0000d6 300a      cpi temp_r16, $0A
C:0000d7 f41c      brge hex_to_letter_geA
C:0000d8 5d00      subi temp_r16, -0x30
C:0000d9 940c 00e1 jmp hex_to_letter_done
          hex_to_letter_geA:
C:0000db 3100      cpi temp_r16, $10
C:0000dc f41c      brge 	hex_to_letter_out_of_range
C:0000dd 5c09      subi temp_r16, -0x37
C:0000de 940c 00e1 jmp hex_to_letter_done
          hex_to_letter_out_of_range:
C:0000e0 e203      ldi temp_r16, '#'
          hex_to_letter_done:
C:0000e1   +    load_addr X, counter_str
C:0000e1 e0a0      ldi XL, low(counter_str)
C:0000e2 e0b1      ldi XH, high(counter_str)
C:0000e3 930d        st X+, temp_r16
C:0000e4 e000        ldi temp_r16, $00
C:0000e5 930c        st X, temp_r16
C:0000e6   +    disp_from_sram counter_str, lcd_LineOne
C:0000e6 e0b1      ldi XH, high(counter_str) 

C:0000e7 e0a0      ldi XL, low(counter_str) 

C:0000e8 e000      ldi r16, lcd_LineOne 

C:0000e9 940e 00b7 call lcd_write_string_4d_mem
C:0000eb 9518        reti
         
         
         
         ;;; Startup Routine
            .cseg
          RESET:
         ;;; Init SP
C:0000ec   +    init_sp
C:0000ec ef0f      ldi r16,low(RAMEND)
C:0000ed bf0d      out SPL,r16
C:0000ee e008      ldi r16,high(RAMEND)
C:0000ef bf0e      out SPH,r16
           ;ldi r16,low(RAMEND)
           ;out SPL,r16
           ;ldi r16,high(RAMEND)
           ;out SPH,r16
         
         
         ;;; Set Timer Registers
           ;; Waveform Generation Mode
            .equ wgm_hi = (00 << WGM12)   ; Currently set to "Normal" Mode
            .equ wgo_lo = (00 << WGM10)
           ;; Control Registers
C:0000f0 e000        ldi temp_r16, $00
C:0000f1 9300 0080   sts TCCR1A, temp_r16
         
C:0000f3 e004        ldi temp_r16, (0b100 << CS10)   ; Clock Source (Curr: x1 Prescale)
C:0000f4 9300 0081   sts TCCR1B, temp_r16
         
C:0000f6 e000        ldi temp_r16, $00
C:0000f7 9300 0082 	sts TCCR1C, temp_r16
         
           ;; Interupt Mask
C:0000f9 e001        ldi temp_r16, (1 << TOIE1)
C:0000fa 9300 006f   sts TIMSK1, temp_r16
         
         
C:0000fc 940e 001c   call lcd_init_4d              ; Initialize LCD display for 4-bit interface
         
         	;; Clear Display Instruction
C:0000fe e001        ldi temp_r16, lcd_Clear       ; r16 = clear display instruction
C:0000ff 940e 007c   call lcd_write_instruction_4d
         
         
         ;;; Initialize Counter
C:000101 2711        clr interupt_ctr
         
         
         ;;; Enable Interupts
C:000102 9478        sei                           ; Enable those interupts
          sleep_loop:
           ;; Note: Trying out a more simple wait loop for now because sleep needs a more complex implementation
           ;; sleep                         ; Sleep becuase ISR handles everything now
           ;; Note: will enter sleep before any pending interrupt(s)
C:000103 940c 0103   jmp sleep_loop                ; Because return from the interrupt will advance the PC


Segment usage:
   Code      :       237 words (474 bytes)
   Data      :         2 bytes
   EEPROM    :         0 bytes

Assembly completed with no errors.
